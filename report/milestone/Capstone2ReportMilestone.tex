\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{mathtools,setspace,indentfirst,graphicx,float}
\usepackage{fancyhdr} % for header
\usepackage{listings}

\doublespacing{}

\fancyhf{}
\pagestyle{fancy}

\lhead{N Batista, M Inciong, F Truncale}
\chead{\thepage}
\rhead{Fall 2017}
\renewcommand{\headrulewidth}{0pt} % remove the horizontal line along the header

\begin{document}

\thispagestyle{empty}

\begin{titlepage}
  \vspace*{\fill} % i copied this off stackexchange so no i don't know what that asterisk does.
  \begin{center}
    {\Huge Milestone Report --- Optimization of Subgraph Isomorphism Algorithm}\\[0.4cm]
    {\huge by Nelson Batista, Max Inciong, Francesca Truncale}\\[0.5cm]
    {\huge Senior Project II}\\[0.4cm]
    {\huge Professor Jianting Zhang}\\[0.4cm]
    {\LARGE Fall 2017}
  \end{center}
  \vspace*{\fill}
\end{titlepage}

\pagenumbering{roman}
%table of contents
\tableofcontents

\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

%\addcontentsline{toc}{section}{Introduction}
\section{Introduction}

The goal of this project is to understand and optimize an algorithm for solving the NP-complete problem of subgraph isomorphism. An \textit{isomorphism} between two graphs is a mapping from the vertices of one graph, say $G$, to another graph, say $H$, such that any two vertices which are adjacent in $G$ are mapped to vertices which are adjacent in $H$. The subgraph isomorphism problem, in turn, is the problem of determining whether an isomorphism exists between a graph $G$ and any of the subgraphs of a larger search graph, $H$. The issue that makes the subgraph isomorphism problem so difficult to solve for a particular pair of graphs is cycling through the main graph and expanding each node within the graph and checking if each of the generated subgraphs formed from each node is isomorphic to the control graph.

Fortunately, many attempts exist to solve the subgraph isomorphism problem. Among the earliest of these is the famous \textit{Ullmann Algorithm}, proposed by Julian R. Ullmann in his 1976 paper, \textit{An Algorithm for Subgraph Isomorphism}. He first describes a basic, naive approach to finding a mapping from the vertices of a graph to a subgraph of a larger graph. He goes on to define a ``refine'' procedure to dramatically reduce the number of possible mappings that must be checked. These will be covered in greater detail in the next section.

The goal of our project was to take this algorithm and improve its performance. Subgraph isomorphism is an expensive problem to solve, and finding multiple possible isomorphisms from one graph to subgraphs of another is even more expensive, so even slight improvements in the algorithm's performance is likely to lead to large performance improvements in any large-scale program which needs to use it often.

%\addcontentsline{toc}{section}{Ullmann Algorithm}
\section{Ullmann Algorithm}

  %\addcontentsline{toc}{subsection}{Naive Approach}
  \subsection{Naive Approach}

  \subsection{``Refine M'' Procedure}

  \subsection{Full Algorithm}

\section{Implementation of the Algorithm}

  \subsection{Python Implementation and Performance}
  Essentially, the Python implementation was the more naive approach to the Ullman Algorithm.



  \begin{lstlisting}[language=Python]
  def find_isomorphism(graph, subgraph):

      assignments = []
      possible_assignments = [[True]*graph.n_vertices() for i in range(subgraph.n_vertices())]
      # TODO remove subgraph instance from graph and run this again with the modified graph
      matches = 0
      if search(graph, subgraph, assignments, possible_assignments):
          #print(assignments)
          print("Match found")
          #return True
         # something like this
          matches += 1
          for node in assignments:
              graph.remove_vertex(node)
         #     optionally put the removed nodes into a new graph and tack that onto a list
         #     idk why max wants that but that's how i'd do it
          matches += find_isomorphism(graph, subgraph)
         #
      print(matches, " matches found")
      return matches
  \end{lstlisting}

  The main function is \texttt{find\_isomorphism}, which is depicted above. The function \texttt{search} is a modified Depth First Search, which is used to find the instance of a subgraph within a larger graph.


  The \texttt{search} function runs  the \texttt{update\_possible\_assignments} function. This particular function has been the subject of refining over the course of the project. At the time of the python implementation, it was the most significant bottleneck.


  This was partially due to the usage of the \texttt{has\_edge} method of the graph class, shown below.


  %TODO: Actually make that caption useful
  \begin{figure}[H]
    \centering

    \begin{lstlisting}[language=Python]
    def has_edge(self, vert1, vert2):
         """ Checks if edge conecting vert1 and vert2 is in the graph
         """
         return ({vert1, vert2} in self.adjacencies) #if adjacent, there's an edge

    \end{lstlisting}
    \caption{This is some has_edge code man}
  \end{figure}

  This method calls the built-in \texttt{in} function of Python lists, and has a runtime complexity of O(n) (see the table at \url{https://wiki.python.org/moin/TimeComplexity}).


  \subsection{Initial C++ Implementation}

  \subsection{Improved C++ Implementation}

  \subsection{Optimizations through OpenMP}

  % TODO more sections
  % TODO rewrite all this
  % TODO put it into the sections
Process
We wanted to understand the algorithm starting from pseudocode. First we gathered pseudocode to determine the algorithm for subgraph isomorphism. From there, we wanted to transcribe it into python, and then into C++ and from there parallelize it using threads. After using the python implementation, we decided to utilize something known as the Ullman algorithm for our C++ implementation. We have also since changed our plan to utilize CUDA and GPGPU to utilizing OpenMP

Graph Class
The graph class that we ended up using is an unweighted directed graph. This means that when searching for isomorphisms, we have to take into consideration the direction of the nodes rather than simply the connections.within each graph. The graphs are unweighted, which means the isomorphism function does not take into account the values contained within each of the nodes.

Python Implementation

Ullman Algorithm

C++ Implementation

OpenMP
OpenMP utilizes a computerâ€™s core in order to do separate work in parallel. We intend to place it where the bottlenecks are. The default number of cores for plenty of computers is four cores. We intend to place the parallelisms where there tend to be plenty of iterations. This means that theoretically, the program should run approximately 4 times faster than without the parallel processes. However, we have to take into consideration the overhead necessary to run OpenMP in the first place. It is more likely that it will take approximately 3 to 3.5 times faster given that the bottlenecks are completely parallelized. The most important place to place the OpenMP is in the refine\_possible\_assignments functions. This function is where the majority of the work goes, and goes through the most iterations. Ideally, we want to  balance the loads equally so that each core in the computer does an equal amount of work so as to maximize the efficiency of the program. However, it should be enough to simply parallelize every iterative process, but that would not be efficient enough. Ideally we would further parallelize in nodes that have plenty of potential assignments. This way the loads are balanced and more work is done in the areas that require more work

Performance
The python program was very inefficient but it was necessary for us to understand what we had to do for a C implementation. It took us between 13 and 16 seconds to determine if isomorphisms existed within our graphs and data.
  \section{Bibliography}
  % TODO use bibtex or something idk i haven't written an actual citation in years

\end{document}
